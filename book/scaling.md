# Configuring a Yii2 Application for an Autoscaling Stack

Note: These instructions are mainly focused on configuring Yii2 to be a stateless application. The deployment method is basic. More efficient deployment methods may be described in the future.

Applications which can suddenly gain large amounts of traffic should handle it by temporarily adding additional servers. This is called auto scaling.

To set up an application for auto scaling, the application needs to be made stateless (generally nothing should be written directly to the application hosting server, so no local Session or Cache storage), and the database needs to be hosted on a separate server.

Setting up a Yii2 application for auto scaling is fairly straight forward:

## Pre-requisities


* Any well performing PaaS (Platform as a Service) solution that supports autoscaling, load balancing, and SQL databases such as Google Cloud (Instance Group + Load Balancer) or Amazon AWS (Elastic Beanstalk)
* Redis or Memcached server. Easily launched on popular PaaS platforms with [Bitnami Cloud](https://bitnami.com/cloud). Redis generally performs better over Memcached, so this page will be focusing on working with Redis.
* Hosted Database server (Most PaaS platforms let you easily launch one i.e. Google SQL).

## Making your application Stateless

Use a Yii2 supported Session Storage/Caching/Logging service such as Redis. Refer to the following resources for further instructions:

 * [Yii2 Class yii\redis\Session](http://www.yiiframework.com/doc-2.0/yii-redis-session.html)
 * [Yii2 Class yii\redis\Cache](http://www.yiiframework.com/doc-2.0/yii-redis-cache.html)
 * [Yii2 Redis Logging Component](https://github.com/JackyChan/yii2-redis-log)

When you run on a PaaS platform, make sure to use the Redis server's internal IP and not the external IP. This is essential for your application's speed.


A redis server doesn't require much disk space. It runs on RAM. This guide recommends any new application to start with at least 1GB RAM, and vertically scaling up the instance (i.e. upgrade to a more RAM) depending on usage. You can measure your RAM usage by SSH'ing into the redis server and running `top`.


Also configure your application to use your hosted database server (hosted by i.e. Google SQL).

## Configuring the Stack

The instructions below may be subject to change and improvement.

Set up a temporary single instance server to configure your application with.

The application must be deployed to the server by Git, so that multiple servers will stay up to date with the application. This guide recommends the following process:

* `git clone` the application into the configured 'www' directory
* Set up a cron job to `git pull` the directory every minute.
* Set up a cron job to `composer install` the directory every minute.

When the application is up and running on the temporary server, create a snapshot of the server and use it to create your scalable server group.

Most PaaS platforms such as Google Cloud Managed Instance Groups and Amazon Elastic Beanstalk let you configure 'start up' commands. The start up command should also install/update the application (using `git clone` or `git pull` depending on if the service image already contains the application's git or not), and a `composer install` command to install all composer packages.

When the server group is set up using a disk based on the snapshot from the temporary server instance, you can remove the temporary server instance.

Your server group is now configured. Set up a load balancer on your PaaS platform (i.e. Load Balancer on Google) for the server group, andset your domain's A or CNAME records to your load balancer's static IP.

## Assets Management

By default Yii generate assets on the fly and store in `web/assets` directory with names that depends on the file created time. If you deploy in multiple servers, the deployment time can be different by several seconds. This can be caused by the difference of latency to the code storage or other factors or especially in autoscaling environment when a new instance can be spun hours after last deployment.

This can cause inconsistencies for URLs generated by different servers for a single asset. Setting the server affinity in the load balancer can avoid this, meaning requests by same user will be directed to the very same server hit by the first request. But this solution is not recommended since you may cache the result of your page in a persistent centralized storage. Furthermore, in autoscaling environment underutilized server can be shut down anytime leaving the next requests served by different server that generated different URL.

A more robust solution is by configuring `hashCallback` in [AssetManager](http://www.yiiframework.com/doc-2.0/yii-web-assetmanager.html#%24hashCallback-detail) so it will not depend on time, rather an idempotent function.

For example, if you deploy your code in exact path in all servers, you can configure the `hashCallback` to something like

```php
function ($path) {
    return hash('md4', $path);
}
```

Some deployment mechanism such as [AWS OpsWorks](https://aws.amazon.com/opsworks/) will deploy your code in very different path between servers, for example using deployment timestamp or commit. You can configure your `hashCallback` to create a hash from relative path of the asset.

```php
function ($path) {
    $relativePath = str_replace(Yii::$app->basePath, '', $path);
    return hash('md4', $relativePath);
}
```

If you use HTTP caching configuration on serving assets like JS/CSS/JPG/etc in your web server (Apache or NGINX), you might .... (ctd, got phone call).
